import type { Request, Response } from "express"
import mongoose from "mongoose"
import { supabase } from "../config/supabase"
import File, { type IFile } from "../models/file"
import Project from "../models/project"
import User from "../models/user"
import { v4 as uuidv4 } from "uuid"

// ‚úÖ FONCTION POUR V√âRIFIER/CR√âER LE BUCKET AVEC PLUS DE D√âTAILS
const ensureBucketExists = async (): Promise<boolean> => {
  try {
    console.log("üîç V√©rification du bucket Supabase...")
    const { data: buckets, error: listError } = await supabase.storage.listBuckets()

    if (listError) {
      console.error("‚ùå Erreur v√©rification buckets:", listError.message)
      return false
    }

    console.log(`üìä Buckets disponibles: ${buckets?.length || 0}`)

    // Afficher tous les buckets pour debug
    buckets?.forEach((bucket) => {
      console.log(`üì¶ Bucket: ${bucket.name} (${bucket.public ? "public" : "priv√©"})`)
    })

    const ifcBucket = buckets?.find((b) => b.name === "ifc-files")

    if (!ifcBucket) {
      console.log("‚ö†Ô∏è Bucket 'ifc-files' non trouv√©, tentative de cr√©ation...")

      try {
        const { data: newBucket, error: createError } = await supabase.storage.createBucket("ifc-files", {
          public: false,
          fileSizeLimit: 100 * 1024 * 1024, // 100MB
        })

        if (createError) {
          console.error("‚ùå Erreur cr√©ation bucket:", createError.message)
          console.log("üìã SOLUTION: Cr√©ez manuellement le bucket dans Supabase Console:")
          console.log("   1. Allez sur votre projet Supabase")
          console.log("   2. Storage ‚Üí New bucket")
          console.log("   3. Nom: 'ifc-files'")
          console.log("   4. Public: NON (d√©coch√©)")
          return false
        }

        console.log("‚úÖ Bucket 'ifc-files' cr√©√© avec succ√®s!")
        return true
      } catch (createErr: any) {
        console.error("‚ùå Exception cr√©ation bucket:", createErr.message)
        return false
      }
    }

    console.log("‚úÖ Bucket 'ifc-files' trouv√© et disponible")
    return true
  } catch (error: any) {
    console.error("‚ùå Erreur v√©rification bucket:", error.message)
    return false
  }
}

// ‚úÖ UPLOAD MULTIPLE AM√âLIOR√â
export const uploadFiles = async (req: Request, res: Response): Promise<void> => {
  const uploadId = uuidv4().substring(0, 8)
  console.log(`[${uploadId}] üöÄ D√©marrage upload MULTIPLE vers Supabase`)

  // ‚úÖ AUGMENTER LE TIMEOUT DE LA REQU√äTE
  // @ts-ignore - Ajouter un timeout plus long pour les gros fichiers
  req.setTimeout(600000) // 10 minutes
  // @ts-ignore - Augmenter aussi le timeout de la r√©ponse
  res.setTimeout(600000) // 10 minutes

  try {
    // ‚úÖ V√âRIFIER QUE LE BUCKET EXISTE AVANT L'UPLOAD
    const bucketExists = await ensureBucketExists()
    if (!bucketExists) {
      console.error(`[${uploadId}] ‚ùå Bucket ifc-files non disponible`)
      res.status(500).json({
        error: "Bucket Supabase non disponible",
        solution: "Cr√©ez manuellement le bucket dans Supabase Console",
      })
      return
    }

    // V√©rification authentification
    if (!req.user) {
      console.error(`[${uploadId}] ‚ùå Authentification √©chou√©e`)
      res.status(401).json({ error: "Non autoris√©" })
      return
    }

    const user = req.user as { email?: string }
    if (!user.email) {
      console.error(`[${uploadId}] ‚ùå Email utilisateur non trouv√©`)
      res.status(401).json({ error: "Email utilisateur non trouv√©" })
      return
    }

    // Extraction des donn√©es
    const projectId: string = req.body.projectId
    const userEmail: string = user.email

    // ‚úÖ GESTION MULTIPLE FILES - req.files peut √™tre un array ou un objet
    let files: Express.Multer.File[] = []

    if (Array.isArray(req.files)) {
      // Si req.files est un array (upload multiple avec m√™me nom de champ)
      files = req.files
      console.log(`[${uploadId}] üì¶ Fichiers trouv√©s (array): ${files.length}`)
    } else if (req.files && typeof req.files === "object") {
      // Si req.files est un objet avec diff√©rents champs
      files = Object.values(req.files).flat()
      console.log(`[${uploadId}] üì¶ Fichiers trouv√©s (object): ${files.length}`)
    } else if (req.file) {
      // Si un seul fichier
      files = [req.file]
      console.log(`[${uploadId}] üì¶ Fichier unique trouv√©`)
    }

    console.log(`[${uploadId}] üì¶ Donn√©es re√ßues: projectId=${projectId}, fichiers=${files.length}, email=${userEmail}`)

    // Validation
    if (!files || files.length === 0) {
      console.error(`[${uploadId}] ‚ùå Aucun fichier fourni`)
      res.status(400).json({
        error: "Aucun fichier fourni",
        debug: {
          reqFiles: !!req.files,
          reqFile: !!req.file,
          filesType: typeof req.files,
          filesLength: Array.isArray(req.files) ? req.files.length : 0,
          body: req.body,
        },
      })
      return
    }

    if (!projectId) {
      console.error(`[${uploadId}] ‚ùå ProjectId manquant`)
      res.status(400).json({ error: "ProjectId requis" })
      return
    }

    // V√©rification projet
    const project = await Project.findById(projectId)
    if (!project) {
      console.error(`[${uploadId}] ‚ùå Projet non trouv√©: ${projectId}`)
      res.status(404).json({ error: `Projet avec ID ${projectId} non trouv√©` })
      return
    }
    console.log(`[${uploadId}] ‚úÖ Projet trouv√©: ${project.name || projectId}`)

    // Recherche utilisateur
    let userId: mongoose.Types.ObjectId | null = null
    if (userEmail) {
      const userDoc = await User.findOne({ email: userEmail })
      if (userDoc) {
        userId = userDoc._id
        console.log(`[${uploadId}] ‚úÖ Utilisateur trouv√©: ${userId}`)
      }
    }

    // ‚úÖ VARIABLES POUR TRACKING MULTIPLE UPLOADS
    const uploadResults = {
      successful: [] as any[],
      failed: [] as any[],
      downloadURLs: [] as string[],
      fileMetadata: [] as any[],
      newFileIds: [] as mongoose.Types.ObjectId[],
    }

    console.log(`[${uploadId}] üîÑ Traitement de ${files.length} fichier(s) en s√©quentiel...`)

    // ‚úÖ TRAITEMENT S√âQUENTIEL POUR LES GROS FICHIERS
    // Traiter les fichiers un par un pour √©viter les timeouts
    for (let index = 0; index < files.length; index++) {
      const file = files[index]
      const fileId = `${uploadId}-file-${index}`

      console.log(
        `[${fileId}] üìÑ D√©but traitement: ${file.originalname} (${Math.round((file.size / 1024 / 1024) * 100) / 100} MB)`,
      )

      try {
        // Validation format IFC
        if (!file.originalname.toLowerCase().endsWith(".ifc")) {
          const error = `Le fichier ${file.originalname} n'est pas au format IFC`
          console.error(`[${fileId}] ‚ùå ${error}`)
          uploadResults.failed.push({ success: false, error, fileName: file.originalname })
          continue
        }

        // Validation taille fichier (100MB max)
        const maxFileSize = 100 * 1024 * 1024 // 100MB
        if (file.size > maxFileSize) {
          const error = `Le fichier ${file.originalname} est trop volumineux (${Math.round(file.size / 1024 / 1024)}MB). Taille maximum: 100MB.`
          console.error(`[${fileId}] ‚ùå ${error}`)
          uploadResults.failed.push({ success: false, error, fileName: file.originalname })
          continue
        }

        // G√©n√©ration du chemin Supabase
        const timestamp = Date.now() + index // √âviter les collisions
        const sanitizedName = file.originalname
          .replace(/[^a-zA-Z0-9.-]/g, "_")
          .replace(/_{2,}/g, "_")
          .toLowerCase()

        const fileName = `${timestamp}_${sanitizedName}`
        const supabasePath = `projects/${projectId}/${fileName}`

        console.log(`[${fileId}] üìÇ Chemin Supabase: ${supabasePath}`)

        // ‚úÖ UPLOAD VERS SUPABASE STORAGE AVEC RETRY
        const uploadStartTime = Date.now()
        let uploadSuccess = false
        let uploadError = null
        let uploadData = null

        // Tentatives multiples en cas d'√©chec
        for (let attempt = 1; attempt <= 3; attempt++) {
          if (attempt > 1) {
            console.log(`[${fileId}] üîÑ Tentative ${attempt}/3...`)
            // Attendre 2 secondes entre les tentatives
            await new Promise((resolve) => setTimeout(resolve, 2000))
          }

          try {
            const result = await supabase.storage.from("ifc-files").upload(supabasePath, file.buffer, {
              contentType: "application/octet-stream",
              upsert: true, // √âcraser si existe d√©j√†
            })

            if (result.error) {
              console.error(`[${fileId}] ‚ùå Tentative ${attempt} √©chou√©e:`, result.error.message)
              uploadError = result.error
            } else {
              uploadData = result.data
              uploadSuccess = true
              console.log(`[${fileId}] ‚úÖ Upload r√©ussi √† la tentative ${attempt}`)
              break
            }
          } catch (err: any) {
            console.error(`[${fileId}] ‚ùå Exception tentative ${attempt}:`, err.message)
            uploadError = err
          }
        }

        if (!uploadSuccess) {
          console.error(`[${fileId}] ‚ùå √âchec upload apr√®s 3 tentatives`)
          uploadResults.failed.push({
            success: false,
            error: `Upload failed: ${uploadError?.message || "Unknown error"}`,
            fileName: file.originalname,
          })
          continue
        }

        const uploadDuration = Date.now() - uploadStartTime
        console.log(`[${fileId}] ‚úÖ Upload Supabase r√©ussi en ${uploadDuration}ms`)

        // R√©cup√©ration URL publique
        const { data: urlData } = supabase.storage.from("ifc-files").getPublicUrl(supabasePath)

        if (!urlData?.publicUrl) {
          console.error(`[${fileId}] ‚ùå √âchec r√©cup√©ration URL publique`)
          uploadResults.failed.push({
            success: false,
            error: "Failed to get public URL",
            fileName: file.originalname,
          })
          continue
        }

        console.log(`[${fileId}] ‚úÖ URL publique obtenue`)

        // Sauvegarde dans MongoDB
        const newFile = new File({
          name: file.originalname,
          file_url: urlData.publicUrl,
          file_size: file.size,
          fileType: "IFC",
          project: new mongoose.Types.ObjectId(projectId),
          supabasePath: supabasePath,
          uploadedBy: userId || userEmail,
          ifcMetadata: {
            schema: "IFC2x3",
            application: "Supabase Upload",
            creator: userEmail,
            timestamp: new Date(),
            coordinates: { x: 0, y: 0, z: 0 },
          },
          uploadedAt: new Date(),
        } as IFile)

        await newFile.save()
        console.log(`[${fileId}] ‚úÖ Sauvegarde MongoDB r√©ussie: ${newFile._id}`)

        const result = {
          success: true,
          file: {
            id: (newFile._id as mongoose.Types.ObjectId).toString(),
            name: file.originalname,
            url: urlData.publicUrl,
            size: file.size,
            fileType: "IFC",
            supabasePath: supabasePath,
          },
          fileId: newFile._id,
          downloadUrl: urlData.publicUrl,
        }

        uploadResults.successful.push(result)
        uploadResults.downloadURLs.push(result.downloadUrl)
        uploadResults.fileMetadata.push(result.file)
        uploadResults.newFileIds.push(result.fileId as mongoose.Types.ObjectId)
      } catch (fileError: any) {
        console.error(`[${fileId}] ‚ùå Erreur traitement:`, fileError.message)
        uploadResults.failed.push({
          success: false,
          error: fileError.message,
          fileName: file.originalname,
        })
      }
    }

    console.log(
      `[${uploadId}] üìä R√©sultats: ${uploadResults.successful.length} r√©ussis, ${uploadResults.failed.length} √©chou√©s`,
    )

    // Mise √† jour du projet avec les nouveaux fichiers
    if (uploadResults.newFileIds.length > 0) {
      try {
        await Project.findByIdAndUpdate(
          projectId,
          { $push: { files: { $each: uploadResults.newFileIds } } },
          { new: true },
        )
        console.log(`[${uploadId}] ‚úÖ Projet mis √† jour avec ${uploadResults.newFileIds.length} nouveaux fichiers`)
      } catch (updateError: any) {
        console.error(`[${uploadId}] ‚ùå √âchec mise √† jour projet:`, updateError.message)
      }
    }

    // ‚úÖ R√âPONSE D√âTAILL√âE POUR UPLOAD MULTIPLE
    const successCount = uploadResults.successful.length
    const totalCount = files.length
    const failedCount = uploadResults.failed.length

    const responseData = {
      uploadId,
      success: successCount > 0,
      message: `${successCount}/${totalCount} fichier(s) upload√©(s) avec succ√®s vers Supabase Storage`,

      // Donn√©es des fichiers r√©ussis
      downloadURLs: uploadResults.downloadURLs,
      files: uploadResults.fileMetadata,

      // Statistiques d√©taill√©es
      stats: {
        total: totalCount,
        successful: successCount,
        failed: failedCount,
        successRate: Math.round((successCount / totalCount) * 100),
      },

      // Erreurs d√©taill√©es si il y en a
      errors:
        uploadResults.failed.length > 0
          ? uploadResults.failed.map((f) => ({
              fileName: f.fileName,
              error: f.error,
            }))
          : undefined,

      timestamp: new Date().toISOString(),
      storageProvider: "Supabase",
    }

    if (successCount === 0) {
      console.error(`[${uploadId}] ‚ùå Aucun fichier upload√© avec succ√®s`)
      res.status(400).json({
        error: "Aucun fichier n'a √©t√© upload√© avec succ√®s",
        ...responseData,
      })
      return
    }

    // ‚úÖ SUCC√àS PARTIEL OU TOTAL
    const statusCode = failedCount > 0 ? 207 : 200 // 207 = Multi-Status pour succ√®s partiel
    console.log(`[${uploadId}] ‚úÖ Upload multiple termin√© - Status: ${statusCode}`)

    res.status(statusCode).json(responseData)
  } catch (error: any) {
    console.error(`[${uploadId}] ‚ùå √âchec processus d'upload multiple:`, error.message)
    res.status(500).json({
      error: "√âchec upload multiple",
      details: error.message || String(error),
      uploadId,
      storageProvider: "Supabase",
      timestamp: new Date().toISOString(),
    })
  }
}


export const getProjectFiles = async (req: Request, res: Response): Promise<void> => {
  const requestId = uuidv4().substring(0, 8)
  console.log(`[${requestId}] üîç R√©cup√©ration fichiers projet`)

  try {
    if (!req.user) {
      console.error(`[${requestId}] ‚ùå Authentification √©chou√©e`)
      res.status(401).json({ error: "Non autoris√©" })
      return
    }

    const { id } = req.params
    console.log(`[${requestId}] üìÇ Project ID: ${id}`)

    if (!mongoose.Types.ObjectId.isValid(id)) {
      console.error(`[${requestId}] ‚ùå Format ID projet invalide`)
      res.status(400).json({ error: "ID projet invalide" })
      return
    }

    const project = await Project.findById(id).populate({
      path: "files",
      select: "name file_url file_size uploadedBy supabasePath uploadedAt fileType",
    })

    if (!project) {
      console.error(`[${requestId}] ‚ùå Projet non trouv√©: ${id}`)
      res.status(404).json({ error: "Projet non trouv√©" })
      return
    }

    console.log(`[${requestId}] ‚úÖ Projet trouv√© avec ${project.files?.length || 0} fichiers`)

    const files = await Promise.all(
      (project.files || []).map(async (file: any) => {
        if (file.uploadedBy && mongoose.Types.ObjectId.isValid(file.uploadedBy)) {
          try {
            const user = await User.findById(file.uploadedBy).select("email name")
            if (user) {
              return {
                ...file.toObject(),
                uploadedByEmail: user.email,
                uploadedBy: user._id,
              }
            }
          } catch (e) {
            console.error(`[${requestId}] ‚ùå Erreur population utilisateur pour fichier ${file._id}`, e)
          }
        }
        return file
      }),
    )

    console.log(`[${requestId}] ‚úÖ Fichiers r√©cup√©r√©s avec succ√®s`)
    res.status(200).json(files)
  } catch (error: any) {
    console.error(`[${requestId}] ‚ùå √âchec r√©cup√©ration fichiers projet`, error)
    res.status(500).json({
      error: "√âchec r√©cup√©ration fichiers projet",
      details: error?.message || String(error),
      requestId,
    })
  }
}

export const deleteFile = async (req: Request, res: Response): Promise<void> => {
  const requestId = uuidv4().substring(0, 8)
  console.log(`[${requestId}] üóëÔ∏è D√©but suppression fichier`)

  try {
    if (!req.user) {
      console.error(`[${requestId}] ‚ùå Authentification √©chou√©e`)
      res.status(401).json({ error: "Non autoris√©" })
      return
    }

    const { fileId, projectId, supabasePath } = req.body
    console.log(`[${requestId}] üóëÔ∏è Suppression`, { fileId, projectId, supabasePath })

    if (!fileId) {
      console.error(`[${requestId}] ‚ùå File ID manquant`)
      res.status(400).json({ error: "File ID requis" })
      return
    }

    // Gestion fichiers temporaires
    if (fileId.startsWith("temp-")) {
      if (supabasePath) {
        try {
          const { error: deleteError } = await supabase.storage.from("ifc-files").remove([supabasePath])

          if (deleteError) {
            console.error(`[${requestId}] ‚ùå Suppression Supabase √©chou√©e pour fichier temp`, deleteError)
          } else {
            console.log(`[${requestId}] ‚úÖ Fichier temporaire supprim√© de Supabase: ${supabasePath}`)
          }
        } catch (storageError) {
          console.error(`[${requestId}] ‚ùå Erreur suppression Supabase pour fichier temp`, storageError)
        }
      }

      res.status(200).json({
        success: true,
        message: "Fichier temporaire supprim√© avec succ√®s",
        deletedFile: { id: fileId, supabasePath },
        requestId,
      })
      return
    }

    // Gestion fichiers MongoDB normaux
    const fileToDelete = await File.findById(fileId)
    if (!fileToDelete) {
      console.error(`[${requestId}] ‚ùå Fichier non trouv√© en base: ${fileId}`)
      res.status(404).json({ error: "Fichier non trouv√©" })
      return
    }

    console.log(`[${requestId}] ‚úÖ Fichier trouv√© en base: ${fileToDelete.name}`)

    const pathToDelete = fileToDelete.supabasePath || supabasePath
    console.log(`[${requestId}] üóëÔ∏è Chemin Supabase √† supprimer: ${pathToDelete}`)

    // Suppression de Supabase Storage
    if (pathToDelete) {
      try {
        const { error: deleteError } = await supabase.storage.from("ifc-files").remove([pathToDelete])

        if (deleteError) {
          console.error(`[${requestId}] ‚ùå Suppression Supabase Storage √©chou√©e`, deleteError)
        } else {
          console.log(`[${requestId}] ‚úÖ Fichier supprim√© de Supabase Storage`)
        }
      } catch (storageError) {
        console.error(`[${requestId}] ‚ùå Erreur suppression Supabase Storage`, storageError)
      }
    }

    // Suppression de MongoDB
    const deleteResult = await File.findByIdAndDelete(fileId)
    if (!deleteResult) {
      console.error(`[${requestId}] ‚ùå Fichier d√©j√† supprim√© de la base`)
      res.status(404).json({ error: "Fichier d√©j√† supprim√©" })
      return
    }

    console.log(`[${requestId}] ‚úÖ Fichier supprim√© de MongoDB`)

    // Suppression de la r√©f√©rence dans le projet
    const projectToUpdate = projectId || fileToDelete.project
    if (projectToUpdate) {
      await Project.findByIdAndUpdate(
        projectToUpdate,
        { $pull: { files: new mongoose.Types.ObjectId(fileId) } },
        { new: true },
      )
      console.log(`[${requestId}] ‚úÖ R√©f√©rence fichier supprim√©e du projet`)
    }

    res.status(200).json({
      success: true,
      message: "Fichier supprim√© avec succ√®s de Supabase Storage",
      deletedFile: {
        id: fileId,
        name: fileToDelete.name,
        supabasePath: pathToDelete,
      },
      requestId,
    })
  } catch (error: any) {
    console.error(`[${requestId}] ‚ùå Suppression fichier √©chou√©e`, error)
    res.status(500).json({
      error: "Suppression √©chou√©e",
      details: error?.message || String(error),
      requestId,
      storageProvider: "Supabase",
    })
  }
}

export const getFileById = async (req: Request, res: Response): Promise<void> => {
  const requestId = uuidv4().substring(0, 8)
  console.log(`[${requestId}] üîç R√©cup√©ration fichier par ID`)

  try {
    if (!req.user) {
      console.error(`[${requestId}] ‚ùå Authentification √©chou√©e`)
      res.status(401).json({ error: "Non autoris√©" })
      return
    }

    const { id } = req.params
    console.log(`[${requestId}] üìÑ File ID: ${id}`)

    if (!mongoose.Types.ObjectId.isValid(id)) {
      console.error(`[${requestId}] ‚ùå Format ID fichier invalide`)
      res.status(400).json({ error: "ID fichier invalide" })
      return
    }

    const file = await File.findById(id)

    if (!file) {
      console.error(`[${requestId}] ‚ùå Fichier non trouv√©: ${id}`)
      res.status(404).json({ error: "Fichier non trouv√©" })
      return
    }

    console.log(`[${requestId}] ‚úÖ Fichier r√©cup√©r√©: ${file.name}`)
    res.status(200).json(file)
  } catch (error: any) {
    console.error(`[${requestId}] ‚ùå √âchec r√©cup√©ration fichier`, error)
    res.status(500).json({
      error: "√âchec r√©cup√©ration fichier",
      details: error?.message || String(error),
      requestId,
    })
  }
}